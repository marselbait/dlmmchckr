<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Memecoin Dashboard</title>
    <style>
        /* ... (previous styles remain unchanged) ... */
        #debugInfo {
            margin-top: 20px;
            font-size: 12px;
            color: #666;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <!-- ... (previous HTML structure) ... -->
    <div id="debugInfo"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
    <script>
        let contractAddress = "";
        let minPrice = 0;
        let maxPrice = 1000000;
        let updateInterval;
        let startTime;
        let elapsedInterval;
        let lastPrice = null;

        function debug(message) {
            console.log(message);
            const debugElement = document.getElementById('debugInfo');
            debugElement.textContent += message + '\n';
        }

        function loadFromLocalStorage() {
            debug("Loading from local storage...");
            try {
                const savedData = JSON.parse(localStorage.getItem('memecoinDashboardData'));
                if (savedData) {
                    debug("Saved data found: " + JSON.stringify(savedData));
                    contractAddress = savedData.contractAddress || "";
                    minPrice = savedData.minPrice || 0;
                    maxPrice = savedData.maxPrice || 1000000;
                    document.getElementById('caInput').value = contractAddress;
                    document.getElementById('minInput').value = minPrice;
                    document.getElementById('maxInput').value = maxPrice;
                    document.getElementById('contractAddress').textContent = contractAddress;
                    document.getElementById('minPrice').textContent = `Min: ${minPrice} SOL`;
                    document.getElementById('maxPrice').textContent = `Max: ${maxPrice} SOL`;
                    if (contractAddress) {
                        debug("Starting updates with saved contract address: " + contractAddress);
                        startUpdates();
                    }
                } else {
                    debug("No saved data found");
                }
            } catch (error) {
                debug("Error loading from local storage: " + error.message);
                showError("Error loading saved data. Please reset the dashboard.");
            }
        }

        function updateSettings() {
            debug("Updating settings...");
            const newCA = document.getElementById('caInput').value.trim();
            const newMin = parseFloat(document.getElementById('minInput').value);
            const newMax = parseFloat(document.getElementById('maxInput').value);

            if (newCA) {
                contractAddress = newCA;
                document.getElementById('contractAddress').textContent = contractAddress;
            } else {
                showError("Please enter a valid contract address.");
                return;
            }

            if (!isNaN(newMin)) minPrice = newMin;
            if (!isNaN(newMax)) maxPrice = newMax;

            document.getElementById('minPrice').textContent = `Min: ${minPrice} SOL`;
            document.getElementById('maxPrice').textContent = `Max: ${maxPrice} SOL`;

            saveToLocalStorage();
            startUpdates();
        }

        async function fetchPrice() {
            debug("Fetching price...");
            if (!contractAddress) {
                showError('Please enter a contract address');
                return;
            }

            try {
                const response = await axios.get(`https://api.dexscreener.com/latest/dex/tokens/${contractAddress}`);
                debug('API Response: ' + JSON.stringify(response.data));

                if (response.data && response.data.pairs && response.data.pairs.length > 0) {
                    const sortedPairs = response.data.pairs.sort((a, b) => b.liquidity.usd - a.liquidity.usd);
                    const pair = sortedPairs[0]; // Use the pair with the highest liquidity

                    if (pair && pair.priceNative && pair.baseToken) {
                        const price = parseFloat(pair.priceNative);
                        const tokenName = pair.baseToken.name || 'Unknown Token';
                        debug(`Updating dashboard with price: ${price} and token name: ${tokenName}`);
                        updateDashboard(price, tokenName);
                        clearError();
                    } else {
                        showError('No valid price data found in the API response');
                    }
                } else {
                    showError('No data found for this contract address');
                }
            } catch (error) {
                debug('Error fetching price: ' + error.message);
                showError(`Error fetching price: ${error.message}`);
            }
        }

        function updateDashboard(price, tokenName) {
            const priceElement = document.getElementById('price');
            const tokenNameElement = document.getElementById('tokenName');
            const priceIndicator = document.getElementById('priceIndicator');

            // Format the price to a maximum of 12 decimal places, removing trailing zeros
            const formattedPrice = price.toFixed(12).replace(/\.?0+$/, "");
            priceElement.textContent = `${formattedPrice} SOL`;
            tokenNameElement.textContent = tokenName;

            if (price >= minPrice && price <= maxPrice) {
                priceElement.style.color = 'green';
            } else {
                priceElement.style.color = 'red';
            }

            const percentage = (price - minPrice) / (maxPrice - minPrice) * 100;
            const clampedPercentage = Math.min(Math.max(percentage, 0), 100);
            priceIndicator.style.left = `${clampedPercentage}%`;

            debug(`Dashboard updated - Price: ${formattedPrice}, Token Name: ${tokenName}, Color: ${priceElement.style.color}, Indicator Position: ${clampedPercentage}%`);

            // Add blinking effect if price has changed
            if (lastPrice !== null && price !== lastPrice) {
                priceElement.classList.remove('blink');
                void priceElement.offsetWidth; // Trigger reflow
                priceElement.classList.add('blink');
                debug("Price changed, blinking effect applied");
            }
            lastPrice = price;
        }

        // ... (other functions remain unchanged) ...

        // Load saved data on page load
        window.onload = loadFromLocalStorage;
    </script>
</body>
</html>
